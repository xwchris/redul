{"version":3,"sources":["webpack://Redul/webpack/universalModuleDefinition","webpack://Redul/webpack/bootstrap","webpack://Redul/./src/utils.ts","webpack://Redul/./src/constants.ts","webpack://Redul/./interface.ts","webpack://Redul/./src/element.ts","webpack://Redul/./src/dispatcher.ts","webpack://Redul/./src/hook.ts","webpack://Redul/./src/reconcile.ts","webpack://Redul/./src/fiber.ts","webpack://Redul/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isComponent","type","EffectTag","FiberNodeTag","TEXT_ELEMENT_TYPE","ROOT_FIBER_NODE","ENOUGH_TIME","transformElementInputsToElements","args","eles","Array","isArray","concat","filter","element","isBoolean","map","props","nodeValue","children","isEvent","test","computeEventName","replace","toLowerCase","getNearestParentDom","fiberNode","currentFiberNode","parent","tag","COMPONENT_NODE","statNode","resolveFiberNode","parentDomNode","effectTag","oldDomNode","ADD","domNode","createDomNode","appendChild","REMOVE","removeChild","UPDATE","prevProps","nextProps","nextPropsKeys","keys","prevPropsKeys","attachedProps","removedProps","length","nextPropsKey","indexOf","prevPropsKey","diffAndExtraProps","extractAttrsAndEventsFromProps","events","attrs","eventName","eventValue","removeEventListener","attrName","isHTMLElement","removeAttribute","removeAllDomNodeAttrsAndEvents","attachDomNodeAttrsAndEvents","updateDomNode","alternate","REPLACE","replaceChild","resolveHostFiberNode","document","createTextNode","createElement","addEventListener","nameAndValue","selectAttrNameAndValue","setAttribute","current","originValue","join","dispatcher","render","rootFiberNode","effects","parentDom","clearDomContent","innerHTML","workInProgressHook","workInProgressFiberNode","componentUpdateQueue","isHookOnUpdateStage","isMount","mountWorkInProgressHook","hook","memoizedState","dispatch","next","update","hooks","updateWorkInProgressHook","baseReducer","state","action","mountUseReducer","reducer","initState","dispatchAction","updateUseReducer","isEqualDeps","prevDeps","nextDeps","Math","min","is","pushHookEffect","destroy","deps","effect","push","newState","taskQueue","nextUnitWork","requestIdleCallback","performWork","scheduleUpdate","callback","didTimeout","timeRemaining","workInProgressRootFiberNode","deadline","shift","isPartialStateChanged","HOST_ROOT_NODE","flushTaskQueue","resolveNextUnitWork","unitWork","Component","alternateFiberNode","parentFiberNode","oldFiberNode","child","prevFiberNode","newFiberNode","mergeEffectTag","NOTHING","sibling","cloneChildFiberNodes","setWorkInProgressFiberNode","updateQueue","reconcileChildren","beginComponentNodeUnitWork","beginHostNodeUnitWork","beginUnitWork","completeUnitWork","performUnitWork","alternateParentFiberNode","prevChildFiberNode","alternateChildFiberNode","childElement","childFiberNode","transformElementToFiberNode","resolveEffectTag","resolveAlternateFiberNodesAsRemoveEffectTag","HOST_NODE","currentEffectTag","oldEffectTag","max","hookEffect","commitUnitWorkHooks","initProps","assign","containerDom","createRootFiberNode","useState","isInitStateFunc","mountUseState","useReducer","useEffect","undefined","updateUseEffect","mountUseEffect","useCallback","updateUseCallback","mountUseCallback","useMemo","nextCreate","nextValue","updateUseMemo","mountUseMemo","useRef","initValue","ref","mountUseRef"],"mappings":"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","file":"redul.production.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Redul\"] = factory();\n\telse\n\t\troot[\"Redul\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { FunctionComponent } from \"../redul\";\n\nexport function isBoolean(value: unknown): value is boolean {\n    return typeof value === 'boolean'\n}\n\nexport function arraify<T>(value: T | T[]) {\n    return Array.isArray(value) ? value : [value]\n}\n\nexport function isComponent(type?: string | FunctionComponent) {\n    return typeof type === 'function'\n}\n","export const TEXT_ELEMENT_TYPE = '@@redul/text-node'\nexport const ROOT_FIBER_NODE = '@@redul/root-fiber-node'\n\nexport const ENOUGH_TIME = 1\n","// fiber effect\nexport enum EffectTag {\n    NOTHING,\n    UPDATE,\n    REPLACE,\n    ADD,\n    REMOVE\n}\n\nexport enum FiberNodeTag {\n    HOST_ROOT_NODE = 1,\n    HOST_NODE,\n    COMPONENT_NODE\n}\n","import { isBoolean, arraify } from \"./utils\";\nimport { TEXT_ELEMENT_TYPE } from './constants'\nimport { ElementType, ElementInput, Element, ElementProps } from '../redul'\n\n// create element node\nexport function createElement(type: ElementType, initProps: ElementProps, ...args: ElementInput[]): Element {\n    const props = Object.assign({}, initProps);\n    const children = transformElementInputsToElements(args)\n\n    props.children = children;\n    return { type, props, children };\n}\n\nfunction createTextElement(text: string | number): Element<{nodeValue: string | number}> {\n    return {\n        type: TEXT_ELEMENT_TYPE,\n        props: { nodeValue: text, children: [] },\n        children: []\n    }\n}\n\nexport function transformElementInputsToElements(args: ElementInput | ElementInput[]) {\n    const eles = arraify(args)\n    const rawElements = ([] as ElementInput[]).concat(...eles).filter(element => element != null && !isBoolean(element)) as (string | number | Element)[];\n    return rawElements.map(element => element instanceof Object ? element : createTextElement(element));\n}\n","import { FiberNode, ElementProps, HTMLElementOrText } from '../redul'\nimport { EffectTag, FiberNodeTag } from '../interface'\nimport { TEXT_ELEMENT_TYPE } from './constants';\n\nconst isEvent = (key: string) => /on\\w+/.test(key)\nconst computeEventName = (key: string) => key.replace(/^on/, '').toLowerCase() as keyof HTMLElementEventMap\n\nconst dispatcher = {\n    render: (rootFiberNode: FiberNode) => {\n        const effects = rootFiberNode.effects\n        // console.log('render', effects.map(item => ([item.type, item.effectTag])))\n\n        for (let i = 0; i < effects.length; i++) {\n            const fiberNode = effects[i]\n            const parentDom = getNearestParentDom(fiberNode)\n            if (parentDom) {\n                resolveFiberNode(fiberNode, parentDom)\n                // reset effectTag\n                fiberNode.effectTag = null\n            }\n        }\n    },\n    clearDomContent(domNode: HTMLElement) {\n        domNode.innerHTML = ''\n    }\n}\n\nfunction getNearestParentDom(fiberNode: FiberNode) {\n    let currentFiberNode = fiberNode.parent;\n    while (currentFiberNode) {\n        if (currentFiberNode.tag !== FiberNodeTag.COMPONENT_NODE) {\n            return currentFiberNode.statNode\n        }\n\n        currentFiberNode = currentFiberNode.parent\n    }\n    return null\n}\n\nfunction resolveFiberNode(fiberNode: FiberNode, parentDomNode: HTMLElementOrText) {\n    if (fiberNode.tag === FiberNodeTag.COMPONENT_NODE) {\n        resolveComponentFiberNode(fiberNode, parentDomNode)\n    } else {\n        resolveHostFiberNode(fiberNode, parentDomNode)\n    }\n}\n\nfunction resolveComponentFiberNode(fiberNode: FiberNode, parentDomNode: HTMLElementOrText) {\n    // do nothing\n}\n\nfunction resolveHostFiberNode(fiberNode: FiberNode, parentDomNode: HTMLElementOrText) {\n    const effectTag = fiberNode.effectTag\n    if (!effectTag) {\n        return\n    }\n\n    const oldDomNode = fiberNode.statNode\n\n    if (effectTag === EffectTag.ADD) {\n        const domNode = createDomNode(fiberNode.type as string, fiberNode.props)\n        fiberNode.statNode = domNode\n        parentDomNode.appendChild(domNode)\n    }\n\n    if (oldDomNode) {\n        if (effectTag === EffectTag.REMOVE) {\n            parentDomNode.removeChild(oldDomNode)\n        } else if (effectTag === EffectTag.UPDATE) {\n            updateDomNode(oldDomNode, fiberNode.alternate && fiberNode.alternate.props, fiberNode.props)\n        } else if (effectTag === EffectTag.REPLACE) {\n            const domNode = createDomNode(fiberNode.type as string, fiberNode.props)\n            fiberNode.statNode = domNode\n            parentDomNode.replaceChild(domNode, oldDomNode)\n        }\n    }\n}\n\nfunction createDomNode(type: string, props: ElementProps<any>) {\n    let domNode: HTMLElementOrText | null = null\n    if (type === TEXT_ELEMENT_TYPE) {\n        // nodeValue will update later when attach attributes\n        domNode = document.createTextNode('')\n    } else {\n        domNode = document.createElement(type)\n    }\n\n    if (props) {\n        attachDomNodeAttrsAndEvents(domNode, props)\n    }\n    return domNode\n}\n\nfunction updateDomNode(domNode: HTMLElementOrText, prevProps: ElementProps<any>, nextProps: ElementProps<any>) {\n    if (nextProps) {\n        const { attachedProps, removedProps } = diffAndExtraProps(prevProps, nextProps)\n\n        removeAllDomNodeAttrsAndEvents(domNode, removedProps)\n        attachDomNodeAttrsAndEvents(domNode, attachedProps)\n    }\n}\n\nfunction diffAndExtraProps(prevProps: ElementProps<any>, nextProps: ElementProps<any>) {\n    const nextPropsKeys = Object.keys(nextProps || {})\n    const prevPropsKeys = Object.keys(prevProps || {})\n    const attachedProps: ElementProps<any> = {}\n    const removedProps: ElementProps<any> = {}\n\n    for (let i = 0; i < nextPropsKeys.length; i++) {\n        const nextPropsKey = nextPropsKeys[i]\n        const shouldAttachPropsKey = (prevPropsKeys.indexOf(nextPropsKey) !== -1 && prevProps[nextPropsKey] !== nextProps[nextPropsKey]) || prevPropsKeys.indexOf(nextPropsKey) === -1\n        if (shouldAttachPropsKey) {\n            attachedProps[nextPropsKey] = nextProps[nextPropsKey]\n        }\n    }\n    for (let i = 0; i < prevPropsKeys.length; i++) {\n        const prevPropsKey = prevPropsKeys[i]\n        if ((prevPropsKey in attachedProps) || !(prevPropsKey in nextProps)) {\n            removedProps[prevPropsKey] = prevProps[prevPropsKey]\n        }\n    }\n\n    return { attachedProps, removedProps }\n}\n\nfunction attachDomNodeAttrsAndEvents(domNode: HTMLElementOrText, props: ElementProps<any>) {\n    const { events, attrs } = extractAttrsAndEventsFromProps(props)\n\n    for (let eventName in events) {\n        const eventValue = events[eventName]\n        domNode.addEventListener(eventName, eventValue)\n    }\n\n    for (let attrName in attrs) {\n        // deal ref\n        if (attrName === 'ref') {\n            if (typeof attrs['ref'] === 'object') {\n                attrs['ref'].current = domNode\n            }\n            continue\n        }\n\n        const nameAndValue = selectAttrNameAndValue(attrName, attrs[attrName])\n        if (!nameAndValue) {\n            continue\n        }\n        const { name, value } = nameAndValue\n        if (isHTMLElement(domNode)) {\n            domNode.setAttribute(name, value)\n        } else if (name === 'nodeValue') {\n            domNode.nodeValue = value\n        }\n    }\n}\n\nfunction extractAttrsAndEventsFromProps(props: ElementProps<any>) {\n    let events: Partial<ElementProps<any>> = {}\n    let attrs: Partial<ElementProps<any>> = {}\n\n    for (let key in props) {\n        if (isEvent(key)) {\n            events[computeEventName(key)] = props[key]\n        } else {\n            attrs[key] = props[key]\n        }\n    }\n    return { events, attrs }\n}\n\nfunction isHTMLElement(domNode: HTMLElementOrText): domNode is HTMLElement {\n    return (domNode as HTMLElement).setAttribute != null\n}\n\nfunction removeAllDomNodeAttrsAndEvents(domNode: HTMLElementOrText, props: ElementProps<any>) {\n    const { events, attrs } = extractAttrsAndEventsFromProps(props)\n\n    // remove all events\n    for (let eventName in events) {\n        const eventValue = events[eventName]\n        domNode.removeEventListener(eventName, eventValue)\n    }\n\n     // remove all attrs\n    for (let attrName in attrs) {\n        if (isHTMLElement(domNode)) {\n            domNode.removeAttribute(attrName)\n        } else if (attrName === 'nodeValue') {\n            domNode.nodeValue = ''\n        }\n    }\n}\n\nfunction selectAttrNameAndValue(key: string, originValue: any) {\n    let name = key\n    let value = originValue\n\n    if (key === 'htmlFor') {\n        name = key\n    } else if (key === 'className') {\n        name = 'class'\n    } else if (key === 'style' && typeof value === 'object') {\n        value = Object.keys(value).map(key => `${key}: ${value[key]}`).join(';')\n    } else if (key === 'children') {\n        return null\n    }\n\n    return { name, value }\n}\n\nexport default dispatcher\n","import { Hook, FiberNode, HookEffect, UpdateQueue } from \"../redul\";\nimport { scheduleUpdate } from './reconcile'\n\nlet workInProgressHook: Hook | null = null\nlet workInProgressFiberNode: FiberNode | null = null\n\nlet componentUpdateQueue: HookEffect[] = []\n\nexport function setWorkInProgressFiberNode(fiberNode: FiberNode) {\n    workInProgressFiberNode = fiberNode\n}\n\nexport function resetWorkInProgressHook() {\n    if (workInProgressFiberNode) {\n        // mark component fiber as mounted\n        workInProgressFiberNode.updateQueue = componentUpdateQueue\n    }\n    workInProgressHook = null\n    componentUpdateQueue = []\n}\n\nfunction isHookOnUpdateStage() {\n    return !!(workInProgressFiberNode && workInProgressFiberNode.isMount)\n}\n\nfunction mountWorkInProgressHook<S>() {\n    const hook: Hook<S> = {\n        memoizedState: null,\n        dispatch: null,\n        next: null,\n        update: 0\n    }\n\n    if (workInProgressHook === null) {\n        // first hook of hook link list\n        workInProgressHook = hook\n        // save in work-in-progress fiber\n        if (workInProgressFiberNode) {\n            workInProgressFiberNode.hooks = workInProgressHook\n        }\n    } else {\n        workInProgressHook.next = hook\n        workInProgressHook = workInProgressHook.next\n    }\n\n    return hook\n}\n\n\nfunction updateWorkInProgressHook<S>() {\n    // hooks never be null\n    let hook: Hook<S> | null = null\n    if (workInProgressHook === null) {\n        hook = workInProgressFiberNode!.hooks!\n    } else {\n        hook = workInProgressHook.next!\n    }\n    workInProgressHook = hook\n\n    return hook\n}\n\nfunction isInitStateFunc<S>(initState: S | (() => S)): initState is () => S {\n    return typeof initState === 'function'\n}\n\nfunction baseReducer<S, A>(state: S, action: A) {\n    return typeof action === 'function' ? action(state) : action\n}\n\n// useState\nfunction mountUseState<S>(initState: S | (() => S)): [S, (newState: S) => void] {\n    const calcInitState = isInitStateFunc(initState) ? initState() : initState\n    return mountUseReducer(baseReducer, calcInitState)\n}\n\nfunction updateUseState<S>(): [S | null, ((newState: S) => void) | null] {\n    return updateUseReducer(baseReducer)\n}\n\n// useReducer\nfunction mountUseReducer<S, A>(reducer: (state: S, action: A) => S, initState: S): [S, (action: A) => void] {\n    const hook = mountWorkInProgressHook<S>()\n    const memoizedState = hook.memoizedState = initState\n    const currentFiberNode = workInProgressFiberNode\n    const dispatch =  hook.dispatch = (action: A) => dispatchAction(hook, currentFiberNode, reducer(initState, action))\n    return [memoizedState, dispatch]\n}\n\nfunction updateUseReducer<S, A>(reducer: (state: S, action: A) => S): [S | null, (action: A) => void] {\n    const hook = updateWorkInProgressHook<S>()\n    const currentFiberNode = workInProgressFiberNode\n    const dispatch = hook.dispatch = (action: A) => dispatchAction(hook, currentFiberNode, reducer(hook.memoizedState as S, action))\n    return [hook.memoizedState, dispatch]\n}\n\n// useEffect\nfunction mountUseEffect(create: () => (() => void) | void, deps?: any[]) {\n    const hook = mountWorkInProgressHook<HookEffect>()\n    const nextDeps = deps === undefined ? null : deps\n    hook.memoizedState = pushHookEffect(create, null, nextDeps)\n}\n\nfunction updateUseEffect(create: () => (() => void) | void, deps?: any[]) {\n    const hook = updateWorkInProgressHook<HookEffect>()\n    const nextDeps = deps === undefined ? null : deps\n    const hookEffect: HookEffect | null = hook.memoizedState\n    const prevDeps = hookEffect && hookEffect.deps || null\n\n    if (!isEqualDeps(prevDeps, nextDeps)) {\n        const destroy = hookEffect && hookEffect.destroy || null\n        hook.memoizedState = pushHookEffect(create, destroy, nextDeps)\n    }\n}\n\n// useMemo\nfunction mountUseMemo<T>(nextCreate: () => T, deps?: any[] | null) {\n    const hook = mountWorkInProgressHook<[T, any[] | null]>()\n    const nextDeps = deps === undefined ? null : deps\n    const nextValue = nextCreate()\n    hook.memoizedState = [nextValue, nextDeps]\n    return nextValue\n}\n\nfunction updateUseMemo<T>(nextCreate: () => T, deps?: any[] | null) {\n    const hook = updateWorkInProgressHook<[T, any[] | null]>()\n    const nextDeps = deps === undefined ? null : deps\n    const [_, prevDeps] = hook.memoizedState!\n\n    if (!isEqualDeps(prevDeps, nextDeps))  {\n        const nextValue = nextCreate()\n        hook.memoizedState = [nextValue, nextDeps]\n    }\n    return hook.memoizedState![0]\n}\n\n// useCallback\nfunction mountUseCallback<T>(callback: T, deps?: any[] | null) {\n    const hook = mountWorkInProgressHook<[T, any[] | null]>()\n    const nextDeps = deps === undefined ? null : deps\n    hook.memoizedState = [callback, nextDeps]\n    return callback\n}\n\nfunction updateUseCallback<T>(callback: T, deps?: any[] | null) {\n    const hook = updateWorkInProgressHook<[T, any[] | null]>()\n    const nextDeps = deps === undefined ? null : deps\n    const [_, prevDeps] = hook.memoizedState!\n\n    if (!isEqualDeps(prevDeps, nextDeps)) {\n        hook.memoizedState = [callback, nextDeps]\n    }\n    return hook.memoizedState![0]\n}\n\n// useRef\nfunction mountUseRef<T>(initValue: T) {\n    const hook = mountWorkInProgressHook<{current: T}>()\n    const ref = { current: initValue }\n    hook.memoizedState = ref\n    return ref\n}\n\nfunction updateUseRef<T>() {\n    const hook = updateWorkInProgressHook<{current: T}>()\n    return hook.memoizedState\n}\n\nfunction isEqualDeps(prevDeps: any[] | null, nextDeps: any[] | null) {\n    prevDeps = prevDeps || []\n    nextDeps = nextDeps || []\n    for (let i = 0; i < Math.min(prevDeps.length, nextDeps.length); i++) {\n        if (Object.is(prevDeps[i], nextDeps[i])) {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunction pushHookEffect(create: () => (() => void) | void, destroy: (() => void) | null, deps: any[] | null) {\n    const effect: HookEffect = {\n        create,\n        destroy,\n        deps\n    }\n    componentUpdateQueue.push(effect)\n    return effect\n}\n\nfunction dispatchAction<S>(hook: Hook<S>, fiberNode: FiberNode | null, newState: S) {\n    if (fiberNode) {\n        hook.memoizedState = newState\n        scheduleUpdate(fiberNode)\n    }\n}\n\nfunction useState<S>(initState: S) {\n    if (isHookOnUpdateStage()) {\n        return updateUseState()\n    }\n\n    return mountUseState(initState)\n}\n\nfunction useReducer<S, A>(reducer: (state: S, action: A) => S, initState: S) {\n    if (isHookOnUpdateStage()) {\n        return updateUseReducer(reducer)\n    }\n\n    return mountUseReducer(reducer, initState)\n}\n\nfunction useEffect(create: () => (() => void) | void, deps?: any[]) {\n    if (isHookOnUpdateStage()) {\n        return updateUseEffect(create, deps)\n    }\n\n    return mountUseEffect(create, deps)\n}\n\nfunction useMemo<T>(nextCreate: () => T, deps?: any[] | null) {\n    if (isHookOnUpdateStage()) {\n        return updateUseMemo(nextCreate, deps)\n    }\n\n    return mountUseMemo(nextCreate, deps)\n}\n\nfunction useCallback<T>(callback: T, deps?: any[] | null) {\n    if (isHookOnUpdateStage()) {\n        return updateUseCallback(callback, deps)\n    }\n\n    return mountUseCallback(callback, deps)\n}\n\nfunction useRef<T>(initValue: T) {\n    if (isHookOnUpdateStage()) {\n        return updateUseRef()\n    }\n\n    return mountUseRef(initValue)\n}\n\nexport {\n    useState,\n    useReducer,\n    useEffect,\n    useMemo,\n    useCallback,\n    useRef\n}\n","import { createRootFiberNode, createWorkInProgressRootFiberNode } from './fiber'\nimport { ENOUGH_TIME, ROOT_FIBER_NODE } from './constants'\nimport dispatcher from './dispatcher'\nimport { isComponent } from './utils'\nimport { transformElementInputsToElements } from './element'\nimport { FiberNode, ElementInput, FunctionComponent, Element, RootHTMLElementWithFiberNode } from '../redul'\nimport { EffectTag, FiberNodeTag } from '../interface'\nimport { setWorkInProgressFiberNode, resetWorkInProgressHook } from './hook'\n\nlet taskQueue: FiberNode[] = []\n\nconst requestIdleCallback = ((callback: (deadline: RequestIdleCallbackDeadline) => void) => {\n    callback({\n        didTimeout: true,\n        timeRemaining: () => 100\n    })\n})\n\nlet nextUnitWork: FiberNode | null = null\nlet workInProgressRootFiberNode: FiberNode | null = null\n\nexport function render(element: ElementInput, containerDom: HTMLElement) {\n    // clear all before render\n    dispatcher.clearDomContent(containerDom)\n    const rootFiberNode = createRootFiberNode(element, containerDom)\n    taskQueue.push(rootFiberNode)\n\n    requestIdleCallback(performWork)\n    return containerDom\n}\n\nexport function scheduleUpdate(fiberNode: FiberNode) {\n    taskQueue.push(fiberNode)\n\n    // when no work in progress, start immediately\n    if (!nextUnitWork) {\n        requestIdleCallback(performWork)\n    }\n}\n\nfunction performWork(deadline: RequestIdleCallbackDeadline) {\n    nextUnitWork = resolveNextUnitWork()\n    if (!nextUnitWork) {\n        commitAllWork()\n        return\n    }\n\n    if (deadline.timeRemaining() > ENOUGH_TIME) {\n        nextUnitWork = performUnitWork(nextUnitWork)\n    }\n\n    requestIdleCallback(performWork)\n}\n\nfunction resolveNextUnitWork() {\n    nextUnitWork = nextUnitWork || flushTaskQueue() || null\n    // update work-in-progress root fiber\n    if (nextUnitWork && nextUnitWork.tag === FiberNodeTag.HOST_ROOT_NODE) {\n        workInProgressRootFiberNode = nextUnitWork\n    }\n\n    return nextUnitWork\n}\n\nfunction flushTaskQueue() {\n    const currentFiberNode = taskQueue.shift() || null\n    let rootFiberNode: FiberNode | null = null\n\n    // every update should start from a rootFiberNode\n    if (currentFiberNode && currentFiberNode.tag === FiberNodeTag.COMPONENT_NODE) {\n        currentFiberNode.isPartialStateChanged = true\n\n        if (workInProgressRootFiberNode) {\n            rootFiberNode = createWorkInProgressRootFiberNode(workInProgressRootFiberNode)\n        }\n    } else {\n        rootFiberNode = currentFiberNode\n    }\n\n    return rootFiberNode\n}\n\nfunction commitAllWork() {\n    if (workInProgressRootFiberNode) {\n        // save root fiber\n        (workInProgressRootFiberNode.statNode as RootHTMLElementWithFiberNode)[ROOT_FIBER_NODE] = workInProgressRootFiberNode\n        dispatcher.render(workInProgressRootFiberNode)\n    }\n}\n\nfunction performUnitWork(unitWork: FiberNode) {\n    let fiberNode: FiberNode | null = unitWork\n    beginUnitWork(fiberNode)\n\n    if (fiberNode.child) {\n        return fiberNode.child\n    }\n\n    while(fiberNode) {\n        completeUnitWork(fiberNode)\n        if (fiberNode.sibling) {\n            return fiberNode.sibling\n        }\n        fiberNode = fiberNode.parent || null\n    }\n\n    return null\n}\n\nfunction beginUnitWork(fiberNode: FiberNode) {\n    if (isComponent(fiberNode.type)) {\n        beginComponentNodeUnitWork(fiberNode)\n    } else (\n        beginHostNodeUnitWork(fiberNode)\n    )\n}\n\nfunction beginComponentNodeUnitWork(fiberNode: FiberNode) {\n    const Component = fiberNode.type as FunctionComponent\n    const alternateFiberNode = fiberNode.alternate\n\n    // TODO: judge props whether equal\n    if (alternateFiberNode && alternateFiberNode.props === fiberNode.props && !alternateFiberNode.isPartialStateChanged) {\n        cloneChildFiberNodes(fiberNode)\n        // reset update tag\n        alternateFiberNode.isPartialStateChanged = false\n    } else {\n        // set work-in-progress fiber to use in hooks\n        setWorkInProgressFiberNode(fiberNode)\n        const children = transformElementInputsToElements(Component(fiberNode.props))\n        fiberNode.isMount = true\n        resetWorkInProgressHook()\n        reconcileChildren(children, fiberNode)\n    }\n}\n\nfunction cloneChildFiberNodes(parentFiberNode: FiberNode) {\n    let oldFiberNode = parentFiberNode.alternate!.child\n    let prevFiberNode: FiberNode | null = null\n\n    while (oldFiberNode != null) {\n        const newFiberNode = {\n            ...oldFiberNode,\n            // update effect tag\n            effectTag: mergeEffectTag(EffectTag.NOTHING, oldFiberNode),\n            alternate: oldFiberNode,\n            parent: parentFiberNode,\n        }\n\n        if (prevFiberNode === null) {\n            parentFiberNode.child = newFiberNode\n        } else {\n            (prevFiberNode as FiberNode).sibling = newFiberNode\n        }\n\n        prevFiberNode = newFiberNode\n        oldFiberNode = oldFiberNode.sibling\n    }\n}\n\nfunction beginHostNodeUnitWork(fiberNode: FiberNode) {\n    const { children } = fiberNode\n    reconcileChildren(children, fiberNode)\n}\n\nfunction reconcileChildren(children: Element[], fiberNode: FiberNode) {\n    const alternateParentFiberNode = fiberNode.alternate\n    // fiber node chain\n    let prevChildFiberNode: FiberNode | null = null\n    let alternateChildFiberNode: FiberNode | null = null\n    for (let i = 0; i < children.length; i++) {\n        const childElement = children[i]\n        const childFiberNode = transformElementToFiberNode(childElement)\n        if (i === 0) {\n            fiberNode.child = childFiberNode\n            alternateChildFiberNode = alternateParentFiberNode && alternateParentFiberNode.child || null\n        } else {\n            prevChildFiberNode!.sibling = childFiberNode\n            alternateChildFiberNode = alternateChildFiberNode && alternateChildFiberNode.sibling || null\n        }\n        childFiberNode.parent = fiberNode\n        childFiberNode.alternate = alternateChildFiberNode || null\n        childFiberNode.statNode = alternateChildFiberNode && alternateChildFiberNode.statNode || null\n        childFiberNode.isMount = alternateChildFiberNode && alternateChildFiberNode.isMount || false\n        // copy hooks\n        childFiberNode.hooks = alternateChildFiberNode && alternateChildFiberNode.hooks || null\n\n        const effectTag = resolveEffectTag(childElement, alternateChildFiberNode)\n        childFiberNode.effectTag = mergeEffectTag(effectTag, alternateChildFiberNode)\n\n        prevChildFiberNode = childFiberNode\n    }\n\n    if (alternateChildFiberNode && alternateChildFiberNode.sibling) {\n        resolveAlternateFiberNodesAsRemoveEffectTag(alternateChildFiberNode.sibling, fiberNode)\n    }\n}\n\nfunction transformElementToFiberNode(element: Element): FiberNode {\n    const fiberNode = {\n        tag: isComponent(element.type) ? FiberNodeTag.COMPONENT_NODE : FiberNodeTag.HOST_NODE,\n        ...element,\n        effects: [],\n        statNode: null\n    }\n    return fiberNode\n}\n\nfunction resolveEffectTag(element: Element, alternateFiberNode: FiberNode | null): EffectTag {\n    if (alternateFiberNode) {\n        if (element.type === alternateFiberNode.type) {\n            if (element.props === alternateFiberNode.props) {\n                return EffectTag.NOTHING\n            }\n            return EffectTag.UPDATE\n        } else {\n            return EffectTag.REPLACE\n        }\n    }\n\n    return EffectTag.ADD\n}\n\nfunction mergeEffectTag(currentEffectTag: EffectTag, alternateFiberNode: FiberNode | null): EffectTag | null {\n    // merge effect if alternateFiberNode has effectTag\n    // all effectTag will be reset after render\n    // so if there any effectTag in alternateFiberNode, we should merge it with currentTag\n    const oldEffectTag = alternateFiberNode && alternateFiberNode.effectTag || null\n    if (!oldEffectTag) {\n        return currentEffectTag\n    }\n\n    if (alternateFiberNode) {\n        alternateFiberNode.effectTag = EffectTag.NOTHING\n    }\n    return Math.max(currentEffectTag, oldEffectTag)\n}\n\nfunction resolveAlternateFiberNodesAsRemoveEffectTag(alternateFiberNode: FiberNode | null, fiberNode: FiberNode) {\n    if (alternateFiberNode) {\n        alternateFiberNode.effectTag = EffectTag.REMOVE\n        fiberNode.effects.push(alternateFiberNode)\n    }\n}\n\nfunction completeUnitWork(fiberNode: FiberNode) {\n    const parentFiberNode = fiberNode.parent\n    const effects = fiberNode.effects\n\n    // commit hooks\n    commitUnitWorkHooks(fiberNode)\n\n    if (parentFiberNode) {\n        if (fiberNode.effectTag) {\n            parentFiberNode.effects.push(fiberNode)\n        }\n        parentFiberNode.effects.push(...effects)\n        // reset effects\n        fiberNode.effects = []\n    }\n}\n\nfunction commitUnitWorkHooks(fiberNode: FiberNode) {\n    const updateQueue = fiberNode.updateQueue || []\n    // reset updateQueue\n    for (let i = 0; i < updateQueue.length; i++) {\n        const hookEffect = updateQueue[i]\n        const { create, destroy } = hookEffect\n        if (destroy) {\n            destroy()\n        }\n        if (create) {\n            hookEffect.destroy = create() || null\n        }\n    }\n    fiberNode.updateQueue = []\n}\n","import { FiberNode, ElementInput, RootHTMLElementWithFiberNode } from \"../redul\";\nimport { FiberNodeTag } from '../interface'\nimport { transformElementInputsToElements } from \"./element\";\n\nexport function createRootFiberNode(element: ElementInput | ElementInput[], statNode: RootHTMLElementWithFiberNode): FiberNode {\n    return {\n        tag: FiberNodeTag.HOST_ROOT_NODE,\n        children: transformElementInputsToElements(element),\n        effects: [],\n        statNode,\n        alternate: null\n    }\n}\n\nexport function createWorkInProgressRootFiberNode(fiberNode: FiberNode) {\n    return {\n        tag: FiberNodeTag.HOST_ROOT_NODE,\n        children: fiberNode.children,\n        effects: fiberNode.effects,\n        statNode: fiberNode.statNode,\n        alternate: fiberNode\n    }\n}\n","import { createElement } from './element'\nimport { render } from './reconcile'\nimport { useState, useReducer, useEffect, useCallback, useMemo, useRef } from './hook'\n\nexport default {\n    createElement,\n    render,\n    useState,\n    useReducer,\n    useEffect,\n    useCallback,\n    useMemo,\n    useRef\n}\n"],"sourceRoot":""}